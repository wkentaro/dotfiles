#!/usr/bin/env python3

import argparse
import itertools
import json
import subprocess
import sys

import rich.console


class JqKeysMain:
    def __init__(self, query=None, query_mode=False, force_terminal=False):
        self._query = query
        self._query_mode = query_mode
        self._console = rich.console.Console(
            force_terminal=force_terminal, highlight=False, soft_wrap=True
        )

    def print(self, data, parent_key=None, parent_key_color=None, dry_run=False):
        if parent_key is None:
            parent_key = []
        if parent_key_color is None:
            parent_key_color = []
        assert len(parent_key) == len(parent_key_color)

        color_cycle = itertools.cycle(
            ["red", "green", "blue", "yellow", "magenta", "cyan"]
        )
        key_strings = []
        for key in data:
            current_key = parent_key + [key]

            color = next(color_cycle)
            if parent_key_color and color == parent_key_color[-1]:
                color = next(color_cycle)
            current_key_color = parent_key_color + [color]

            current_key_string = "." + ".".join(current_key)

            if (
                self._query is None
                or (
                    self._query_mode == "startwith"
                    and current_key_string.startswith(self._query)
                )
                or (self._query_mode == "search" and self._query in current_key_string)
                or (self._query_mode == "match" and current_key_string == self._query)
            ):
                key_strings.append(current_key_string)

                if not dry_run:
                    message = ""
                    for key, color in zip(current_key, current_key_color):
                        message += f".[{color}]{key}[/{color}]"
                    self._console.print(message)

            if isinstance(data[key], dict):
                key_strings += self.print(
                    data[key],
                    parent_key=current_key,
                    parent_key_color=current_key_color,
                    dry_run=dry_run,
                )

        return key_strings


def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "query", nargs="?", help="query for jq (used as startwith by default)"
    )
    parser.add_argument(
        "--search", "-s", action="store_true", help="query is used as search"
    )
    parser.add_argument(
        "--match", "-m", action="store_true", help="query is used as match"
    )
    parser.add_argument(
        "--exec", "-e", action="store_true", help="execute the query with jq"
    )
    parser.add_argument(
        "--color-output", "-C", action="store_true", help="force writing with color"
    )
    args = parser.parse_args()

    if args.search and args.match:
        parser.print_usage()
        sys.stderr.write(
            f"jqkeys: error: either --search or --match can be specified\n"
        )
        sys.exit(1)

    string = sys.stdin.read()
    data = json.loads(string)

    query_mode = "startwith"
    if args.search:
        query_mode = "search"
    elif args.match:
        query_mode = "match"

    if args.color_output:
        force_terminal = True
    else:
        force_terminal = None

    key_strings = JqKeysMain(
        query=args.query, query_mode=query_mode, force_terminal=force_terminal
    ).print(data, dry_run=args.exec)

    if args.exec:
        commands = ["jq", ",".join(key_strings)]
        subprocess.run(commands, input=string, text=True)


if __name__ == "__main__":
    main()
